# Rogue Chess - Cursor Rules

## Project Overview
This is a modular C# chess engine framework for experimenting with roguelike mechanics. The project uses .NET 8 and follows a clean architecture pattern with clear separation of concerns.

## Architecture & Design Patterns

### Core Principles
- **Modular Design**: All components implement interfaces and can be easily swapped
- **Immutable State**: GameState is immutable, changes create new instances
- **Event-Driven**: All state changes flow through a candidate → hooks → commit pipeline
- **Decorator Pattern**: Pieces can be enhanced with abilities via decorators
- **Strategy Pattern**: Rulesets, controllers, and game modes are pluggable

### Key Components
- **Pieces**: Implement `IPiece` interface, expose pseudo-legal moves
- **Boards**: Implement `IBoard` interface, manage piece/tile state
- **Rulesets**: Implement `IRuleSet` interface, determine move legality
- **Controllers**: Implement `IPlayerController` interface, decide moves
- **GameEngine**: Central orchestrator managing state transitions
- **Events**: All changes emit `GameEvent`s for UI/AI subscription

## Code Style & Conventions

### C# Standards
- Use `nullable enable` and handle nulls explicitly
- Prefer `IEnumerable<T>` over `List<T>` for public APIs
- Use `record` types for data containers (e.g., `Move`, `Vector2Int`)
- Implement `ICloneable` pattern for deep cloning where needed
- Use `partial class` for large classes split across files

### Naming Conventions
- **Interfaces**: Prefix with `I` (e.g., `IPiece`, `IBoard`)
- **Abstract Classes**: Suffix with `Base` (e.g., `PieceBase`, `StatusEffectBase`)
- **Decorators**: Suffix with `Decorator` (e.g., `ExplodingDecorator`)
- **Status Effects**: Suffix with `Status` (e.g., `BurningStatus`)
- **Rule Sets**: Suffix with `RuleSet` (e.g., `StandardChessRuleSet`)
- **Controllers**: Suffix with `Controller` (e.g., `HumanController`)

### File Organization
- Group related functionality in folders (Pieces/, Controllers/, etc.)
- Use partial classes for large components (GameEngine split across multiple files)
- Keep interfaces in separate files from implementations
- Place decorators in `Decorators/` subfolder

## Development Guidelines

### When Adding New Pieces
1. Implement `IPiece` interface
2. Place in `Engine/Pieces/StandardPieces/` or appropriate subfolder
3. Override `GetPseudoLegalMoves()` for movement logic
4. Override `OnMove()`, `OnCapture()` for special abilities
5. Implement `GetValue()` for AI evaluation
6. Ensure `Clone()` creates deep copies

### When Adding New Decorators
1. Inherit from `PieceDecoratorBase`
2. Override relevant methods (`OnMove`, `OnCapture`, `GetValue`, etc.)
3. Place in `Engine/Pieces/Decorators/`
4. Follow decorator pattern - wrap existing piece functionality

### When Adding New Status Effects
1. Implement `IStatusEffect` interface
2. Inherit from `StatusEffectBase` for common functionality
3. Override `OnTurnStart()` for tick-based effects
4. Place in `Engine/StatusEffects/`
5. Ensure `Clone()` creates deep copies

### When Adding New Rule Sets
1. Implement `IRuleSet` interface
2. Override `GetLegalMoves()` to filter pseudo-legal moves
3. Override `IsGameOver()` for win condition logic
4. Place in `Engine/RuleSets/`

### When Adding New Controllers
1. Implement `IPlayerController` interface
2. Override `SelectMove()` to return chosen move
3. Place in `Engine/Controllers/`
4. Consider AI evaluation using `GameState.Evaluate()`

### When Adding New Tiles
1. Implement `ITile` interface
2. Override `CanEnter()`, `OnEnter()`, `OnTurnStart()` as needed
3. Place in `Engine/Tiles/`
4. Ensure tiles don't break game state immutability

## Event System Guidelines

### Event Flow
1. **Candidate Events**: Generated by pieces/tiles during move processing
2. **Hooks**: Can modify or cancel candidate events
3. **Game Events**: Final events that are published and stored in history

### When Adding New Events
1. Add new `GameEventType` enum value
2. Create corresponding payload class
3. Update event processing in `GameEngine`
4. Ensure events are immutable and serializable

## Testing & Debugging

### Unit Testing
- Test pieces in isolation with mock GameState
- Test rule sets with various board positions
- Test decorators by wrapping base pieces
- Use `GameState.Simulate()` for move testing

### Debugging
- Use `GameEngine.History` to inspect state changes
- Subscribe to `OnEventPublished` for event tracing
- Use `GameState.Evaluate()` to understand AI decisions

## Performance Considerations

### Memory Management
- GameState cloning can be expensive - use simulation for AI
- Consider object pooling for frequently created objects
- Be mindful of LINQ allocations in hot paths

### AI Optimization
- Use `GameState.Simulate()` for move evaluation
- Cache expensive calculations (piece values, legal moves)
- Consider iterative deepening for minimax

## Common Patterns

### Piece Movement
```csharp
public IEnumerable<Move> GetPseudoLegalMoves(GameState state)
{
    // Generate moves based on piece type
    // Don't check for check/checkmate (handled by ruleset)
    // Return all possible moves from current position
}
```

### Decorator Implementation
```csharp
public class ExampleDecorator : PieceDecoratorBase
{
    public override IEnumerable<CandidateEvent> OnMove(Move move, GameState state)
    {
        // Call base implementation
        foreach (var evt in base.OnMove(move, state))
            yield return evt;
            
        // Add custom behavior
        yield return new CandidateEvent(/* custom event */);
    }
}
```

### Status Effect Implementation
```csharp
public class ExampleStatus : StatusEffectBase
{
    public override IEnumerable<CandidateEvent> OnTurnStart(IPiece piece, GameState state)
    {
        // Apply effect each turn
        yield return new CandidateEvent(/* effect event */);
    }
}
```

## Project-Specific Notes

### Current Branch: tier1-pieces
- Working on piece placement initialization
- Draft chess mode implementation
- New decorators being added

### Dependencies
- .NET 8.0
- xUnit for testing
- No external game engine dependencies (engine-agnostic)

### Build Configuration
- Debug/Release configurations
- Multiple target frameworks (net8.0, net9.0-windows)
- Implicit usings enabled
- Nullable reference types enabled

## AI Assistant Guidelines

When working on this project:
1. **Always maintain immutability** - never modify existing GameState instances
2. **Follow the event pipeline** - use CandidateEvents for state changes
3. **Respect the decorator pattern** - enhance pieces, don't modify them directly
4. **Use interfaces** - prefer `IPiece` over concrete piece types
5. **Consider AI implications** - ensure new features work with minimax evaluation
6. **Test thoroughly** - use simulation and cloning for testing
7. **Document complex logic** - especially for custom rules and abilities
8. **Maintain performance** - be mindful of allocations in hot paths
